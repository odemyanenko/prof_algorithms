Tasks
----------------
### Task 1
Реализуйте итерационный (не рекурсивный - мы его сделали!) алгоритм обхода дерева в глубину.
### Task 2
Реализуйте алгоритм вычисления высоты дерева.
### Task 3
Представлено дерево BST.
13
/ \
5   8
/ \
1  30


Каким то образом оно сломалось! Задача: починить дерево. Результат:
13
/ \
5  30
/ \
1   8


Обьяснение: поменяйте местами 8 и 30. Задачу нужно разбить на две подзадачи: 
а) установление факта, что дерево не является BST (какая-то вершина находится не на своем месте…); 
б) собственно, процесс исправления дерева. 

Чтобы тестировать Ваш алгоритм, необходимо реализовать процедуру создания дерева необходимой структуры 
(наш метод add, который мы реализовали на занятии, не подойдет, так как он строит дерево правильно). 
Иногда деревья задают массивом. 
Например, дерево, которое Вам дано по заданию, можно задать массивом [13, 5, 8, 1, 30, null, null]. 
Т.е. это перечисление элементов "по уровням", два последних null - так как у 30 нет ни leftChild, ни rightChild. 
По сути, у Вас добавляется еще одна подзадача - задание дерева нужной структуры - 
задан массив, по нему строим дерево.